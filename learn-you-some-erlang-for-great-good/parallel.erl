%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 12. 並行性
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% フォン=ノイマン型, あるいは逆ポーランド記法の計算機を使っていると,
%% 並行ソフトウェアの作成に長い時間を費やす

%%% Erlangにおける並行性 %%%
%% たくさんのアクターが独立して動くのがErlang.
%% 軽量プロセス(300words in memory, マイクロ秒で起動)と非同期メッセージパッシング を特徴とする.
%%   1. Scalablity
%%   2. Fault Tlerance

%% 並行(Concurrent)性と並列(Parallel)性の区別をちゃんと付けましょう.
%% > よく見られるわかりやすい区別の仕方は、マルチスレッドのプログラムを一つのCPU上で実行している状態は並行で、複数のCPUで実行している状態は並列だというものです。一般的に言うと並行は「複数の実行の流れが一つの基準による順序性を持って(同期的に)実行されている状態」のことで、並列は「複数の実行の流れが基準を持たずに(非同期的に)実行されている状態」のことです。
%% http://d.hatena.ne.jp/icysnow/20070807/p1

%% Erlangの並行処理は高次元の話. プロセスが行う数値計算を高速化するわけではない.


%%% 実践 %%%

1> F = fun() -> 2 + 2 end.
#Fun<erl_eval.20.21881191>
2> spawn(F).
<0.35.0> %% spawnしたあとのpid
4> G = fun(X) -> timer:sleep(10), io:format("~p~n", [X]) end.
#Fun<erl_eval.6.80247286>
6> [spawn(fun() -> G(X) end) || X <- lists:seq(1,10)].
[<0.42.0>,<0.43.0>,<0.44.0>,<0.45.0>,<0.46.0>,<0.47.0>,
 <0.48.0>,<0.49.0>,<0.50.0>,<0.51.0>]
71
72
73
74
76
77
75
79
78
710
%% 実行順序が保証されない


%% self/0で現在のpid(OSのpidとは関係ない)を返す
% 4> self(). %% VimShellの場合
% false
%
% 1> self(). %% shellから直でerl起動した時
% <0.32.0>
% 2> exit(self()).
% ** exception exit: <0.32.0>
% 3> self().
% <0.35.0>


%%% メッセージパッシングは"!" %%%
% 8> self() ! hello.
% hello
% 9> self() ! self() ! double. %% 複数受け渡し

%% メールボックスを確認
% 10> flush().
% Shell got hello
% Shell got double
% Shell got double
% ok

%% おお, 受け取っとる.
%% 受け取った値をごにょごにょするには receive を使う.
%% => dolphins.erl

